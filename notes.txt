一、bit  byte  kb  mb  gb   tb   pb8个比特位（bit）是一字节           短整型              长整型   长长整型    类型char   short   int       long     long long      float   double字节 1          2      4/2       4/8             8               4          8                  16位 2   32位 4                                   32位 4   64位 8                            小数点后六位A  65a  970  48#if  0#endif  条件编译二、%d有符号整型打印%u无符号整型打印char 取值范围：有符号：-128~127      -128=1000 0000          无符号： 0~255（0~2^8-1）sizeof 关键字 以字节为单位常量：使用const修饰，定义的同时需要初始化变量：局部变量：定义局部变量后，要在使用之前初始化，如果没有初始化，默认值为随机值      全局变量：定义后如果没有初始化默认为0当全局变量和局部变量的变量名重复时，优先使用局部变量默认值作用范围生命周期全局变量0整个工程整个程序结束局部变量随机值花括号以内函数运行结束调试1、打断点   F92、快捷键  F5或实心三角3、黄色箭头所指的那一行是还没有被执行的extern 声名外部符号C语言中的常量：
	1. 字面常量
	2. const 修饰的常量
	3. #define 定义的标识符常量
	4. 枚举常量

enum  枚举enum  Day{MON;//没初始化默认为0THU;WEN; }#define定义的常量不可以进行调试#define定义的常量没有类型函数：功能函数名：首字母大写  Add，数组：存放一组相同数据类型的集合如果没有初始化，默认值为随机值局部变量的随机值都是0xcccccc（栈），0xcdcdcd（堆）求数组元素个数―>sizeof(arr)/sizeof(arr[0])注意数组访问不要越界>> 右移  ，左边补符号位<< 左移  ，右边补0int i=-1;printf(“%d\n”,i>>1); //右移1位，补符号位源码：1000 0000 0000 0000 0000 0000 0000 0001反码：1111 1111 1111 1111 1111 1111 1111 1110补码：1111 1111 1111 1111 1111 1111 1111 1111逗号表达式：整个表达式的结果是最后一个表达式int i=(10,20,30,40);输出i=40；关键字
	1. auto  
	2. break   跳出当前循环
	3. continue  结束本趟循环 
	4. typedef   类型重命名  复杂的类型

加上typedef，就会由变量变为相应的类型5、static 修饰局部变量->提升局部变量的生命周期修饰全局变量->作用域被限制了->限制在当前的源文件中修饰函数->作用域被限制了->限制在当前的源文件中面试问题：static和extern的区别define 定义标识符#define  loop for(;;){printf(“aaa”);}#define  LOOP for(; ;)\   //续行符{\prinntf(“aaa”);\}define 定义宏(宏是有参数的，有副作用)注意问题：表达式和参数加括号，以防参数代表表达式#define ADD(x,y)  ((x)+(y))//windows+r  calc 计算器指针小端：低地址存放低数据大端：低地址存放高数据编译器vs 是小端每次运行程序变量的地址是不确定的任何类型的指t{char name[20];char sex[4]int age;;};不能做switch的参数类型有什么？switch的参数类型是整型，不能是flooat或double
针的大小都为4个字节（32位下）
结构体:一种类型，聚合类型
Struct Tag
{
成员列表;
};
struct  studen



函数
       

数组
1、如果数组没有初始化，默认值为随机值（局部数组）
2、数组、结构体......聚合类型的整体赋值只有一次机会，就是在初始化的同时 
3、局部的数组，是在什么时候确定大小的？    编译的时候
                             什么时候分配内存？         运行的时候
                        最大分配多大内存？         1M/2M   栈的大小
char a[5]="abcd";        //默认有‘\0’   字符数组
char a1[5]={'a','b','c','d','e'};       //字符数组
char*p="abcd";           //字符串默认有‘\0’
char a2[]="abcd";          //默认有‘\0’，长度为5

%s 遇到'\0'停止打印
数组名：代表数组首元素的地址

    

int len=sizeof（a）/sizeof(a[0]);     //数组在哪里定义，在哪里使用
sizeof是在编译期间处理的




二维数组
1、不可以同时不写行数和列数
2、可以只写列数，编译器会根据你写的列数来确定行数
操作符
float类型和零比较
if(num>=-0.000001&&num<=0.000001)
11   0000 1011
11<<1   0001 0110     22      11*2^1          左移相当于乘法
11<<2   0010 1100     44       11*2^2
计算机中位运算速度大于 + - * /

11>>1  0000 0101        5  右移相当于除法    11/2^1
11>>2  0000 0010        2    11/2^2

-1>>1   1111 1111       -1
注意：不要移动负数位（结果未定义）

位操作符
13 ：0000 1101
11 ：0000 1011
11^13(按位异或) ：0000 0110


typedef   给类型起别名

判断系统大小端

int mian()
{
int a=0x12345678;
char*p=(char*)&a;
printf("0x%d\n",*p);
}
结果：0x78  -》小端
          0x12 -》大端

void*不能解引用，void没有具体的大小    泛型
任何类型指针的大小都为4字节  （32位)
64位下是8字节
指针的加法：取决于指针的类型，什么类型的指针就加几个字节 
数组名在两种情况下表示整个数组：
1.sizeof（arr）
2.&arr
3.区分
    arr+1    
    &arr+1 
4.指针减指针：俩指针指向同一内存是才有意义
[ ]自带解引用
void 真正发挥的作用在于：
（1） 对函数返回的限定；
（2） 对函数参数的限定。
const int Max=100;
int Array[Max];
在.c 文件中，
编译器会提示出错，而在.cpp 文件中则顺利运行
在 C 语言中，const 修饰的 Max 仍然是变量，只不过是只
读属性罢了；

const 修饰的只读变量必须在定义的同时初始化，
const int *p;     // p 可变，p 指向的对象不可变
int const *p;     // p 可变，p 指向的对象不可变
int *const p;     // p 不可变，p 指向的对象可变
const int *const p;     //指针p 和p 指向的对象都不可变
在平时的授课中发现学生很难记住这几种情况。这里给出一个记忆和理解的方法：
先忽略类型名（编译器解析的时候也是忽略类型名），我们看const 离哪个近。“近水楼
台先得月”，离谁近就修饰谁。
const int *p;     //const 修饰*p,p 是指针，*p 是指针指向的对象，不可变
int const *p;     //const修饰*p,p 是指针，*p 是指针指向的对象，不可变
int *const p;     //const修饰p，p 不可变，p 指向的对象可变
const int *const p;     //前一个const 修饰*p,后一个const 修饰p，指针p 和p 指向的对象
都不可变


结构体和数组一样，是聚合类型  进行整体初始化  定义的时候
结构体自引用时，要以指针的形式定义